import logging, os, sys, time, requests, json
from datetime import datetime
from multiprocessing import Process, Queue
import pandas as pd
import sqlalchemy as s
from workers.worker_base import Worker
import numpy as np
from datetime import date

class ProfanityWorker(Worker):
    def __init__(self, config={}):
        
        # Define the worker's type, which will be used for self identification.
        #   Should be unique among all workers and is the same key used to define 
        #   this worker's settings in the configuration file.
        worker_type = "profanity_worker"

        # Define what this worker can be given and know how to interpret
        # given is usually either [['github_url']] or [['git_url']] (depending if your 
        # worker is exclusive to repos that are on the GitHub platform)
        given = [['github_url']]

        # The name the housekeeper/broker use to distinguish the data model this worker can fill
        #   You will also need to name the method that does the collection for this model
        #   in the format *model name*_model() such as fake_data_model() for example
        models = ['profanity']

        # Define the tables needed to insert, update, or delete on
        #   The Worker class will set each table you define here as an attribute
        #   so you can reference all of them like self.message_table or self.repo_table
        data_tables = ['pull_requests']
        # For most workers you will only need the worker_history and worker_job tables
        #   from the operations schema, these tables are to log worker task histories
        operations_tables = ['worker_history', 'worker_job']

        # Run the general worker initialization
        super().__init__(worker_type, config, given, models, data_tables, operations_tables)

        # Do any additional configuration after the general initialization has been run
        self.config.update(config)

        # If you need to do some preliminary interactions with the database, these MUST go
        # in the model method. The database connection is instantiated only inside of each 
        # data collection process

        # Define data collection info
        self.tool_source = 'Github Profanity Worker'
        self.tool_version = '1.0.0'
        self.data_source = 'Github API'

    def profanity_model(self, task, repo_id):
        """ This is just an example of a data collection method. All data collection 
            methods for all workers currently accept this format of parameters. If you 
            want to change these parameters, you can re-define the collect() method to 
            overwrite the Worker class' version of it (which is the method that calls
            this method).

            :param task: the task generated by the housekeeper and sent to the broker which 
            was then sent to this worker. Takes the example dict format of:
                {
                    'job_type': 'MAINTAIN', 
                    'models': ['fake_data'], 
                    'display_name': 'fake_data model for url: https://github.com/vmware/vivace',
                    'given': {
                        'git_url': 'https://github.com/vmware/vivace'
                    }
                }
            :param repo_id: the collect() method queries the repo_id given the git/github url
            and passes it along to make things easier. An int such as: 27869

        """

        # Any initial database instructions, like finding the last tuple inserted or generate the next ID value

        # Collection and insertion of data happens here

        # ...

        # Register this task as completed.
        #   This is a method of the worker class that is required to be called upon completion
        #   of any data collection model, this lets the broker know that this worker is ready
        #   for another task
        #self.register_task_completion(task, repo_id, 'fake_data')

        def checkText(textIn):
            f = open('badwords.txt', 'r')
            profane = False
            for line in f:
                textIn=str(textIn)
                if(textIn.find(str(" "+line.strip().lower()+" "))!=-1):
                    profane = True
                    break
            return profane

        def writeReport(lines):
            self.logger.info("Writing Profanity Report")
            reportLines = []
            reportLines.append("##Profanity Check Log")
            timeS = time.time()
            reportLines.append("#### Completed on " + date.today().strftime("%B %d, %Y"))
            reportLines.append("\n\n")
            for line in lines:
                reportLines.append("\n\n")
                reportLines.append("###Profanity Found")
                reportLines.append("\n**Text**\n")
                reportLines.append(boldProfane(line['pr_body']))
                reportLines.append("\n\n##Repo ID: " + str(line['repo_id']))
                reportLines.append(("\n\n##Contributer ID: " + str(line['pr_augur_contributor_id'])))
                reportLines.append(("\n\n##Pull Request ID: " + str(line['pull_request_id'])))

            fname = "ProfanityReport" + str(time.time()) + ".md"
            report_file = open(fname, "a")
            for line in reportLines:
                report_file.write(line)
            report_file.close()

        def boldProfane(textIn):
        # Boldens any profane strings within the string.

            f = open('badwords.txt', 'r')
            for line in f:
                if (textIn.find(str(" "+line.strip().lower()+" "))!=-1):
                    textIn = textIn.lower().replace(line.lower(),"**" + line + "**")
            return textIn

        messages = s.sql.text("""
            SELECT *
            FROM pull_requests
        """)
        self.logger.info("Querying database for pull requests")

        result = self.db.execute(messages).fetchall()
        
        self.logger.info("Searching for vulgarity in pull requests")
        a = []
        for row in result:
            if (checkText(row['pr_body'])):
                a.append(row)
        writeReport(a)

